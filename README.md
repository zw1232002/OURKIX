


# OURKIX PHP版本 #
作      者：coly



##（一）本项目主要架构说明：##
>
>1.本项目采用了smarty的2.6.26的模板引擎

>2.对smarty的模板引擎的目录设置进行了更改，其中model是模型（model类目录），view是视图（模板文件目录），controller是控制器（action类目录）

>3.为了方便，在configs目录下，对常用的一些变量进行了配置
  config.inc.php是用来配置一些常量的，如smarty的模板目录，编译目录，缓存开始，缓存周期等
  run.inc.php是用来配置一些运行所需设置的，如定义了项目的绝对路径，开启session，写好自动加载类的函数等等

>4.为了简化代码，本项目采用了单入口的方式，即根目录下只有一个index.php文件，index.php中只有一行代码，即引用了run.inc.php文件
   在run.inc.php中，通过Factory类中的setAction方法，来实现页面分工
  
>5.本项目主要通过get传的两个参数来进行判断，进而区别使用哪个类和哪个方法。a代表action，m代表方法

>6.Factory类判断时，如果a的值为空或者找不到，就直接实例化IndexAction类。同理，m的值不存在执行本类中的index方法，所以每个action子类都要有index方法

>7.模板文件放在view文件夹下，admin目录下是后台的模板。front目录下是前台的模板

>8.本项目连接数据库使用的是PDO。

>9.访问页面的逻辑是：
   ①访问index.php，通过factory判断，进入对应的action子类和对应的方法，如NavAction的index方法
   ②因为Action基类中，保留了模板类和模型类的指针，所以可以在action子类中调用其他两个类，进行数据库操作
   ③返回一些列的数据，存储到变量中，通过assign方法，注入到tpl模板中去，再display对应的模板文件

>10.增删改查数据的逻辑是：
   ①通过对应的action子类，调用对应的model子类的方法，再调用model基类的方法，最后调用到DB类的方法，执行结束之后，再将结果一层层的返回
   ②在model基类中定义了一些必须的存储数据的字段，在子类中可以直接访问，重写
   ③在model子类中，将数据整理好，返回给action子类，直接注入
   ④增删改查的SQL语句写在了DB类中，这样方便迁移。而且SQL语句写的通用性比较强，可以大量使用

##（二）本项目使用的模式说明：##
>
>1.为了实现单例模式，没有直接new smarty()，而是重新定义了一个TPL的类，继承smarty，在TPL类中配置smarty必需的一些配置
   同时，为了实现单例模式，
   需要4个步骤：
   ①私有化构造方法；
   ②私有化clone；
   ③定义一个静态属性，用来存放实例化后的资源句柄。
   ④定义一个静态方法，首先进行判断，已经实例化就直接返回资源句柄，否则实例化，赋值给静态属性，再返回（实例化的时候，已经执行了构造方法，不用担心没有执行）

>2.DB类使用的是组合模式，DB继承PDO之后，因为PDO的construct是public的，子类不能比基类的构造方法权限低
   所以，DB使用的是组合模式，在构造方法中，对PDO进行实例化，传给类自身的属性
   
   
   
##（三）本项目主要类功能说明：##
>
>1.Action类，控制器基类，定义一些公用的方法

>2.Model类，模型基类，继承自DB类，定义一些访问数据库的接口，字段等

>3.DB类，数据库连接和操作类，使用了组合模式，存储增删改查的接口

>4.Factory类，action和model判断类，使用了单例模式，主要通过判断get的值，来决定实例化哪个action子类和哪个方法

>5.Redirect类，进行操作之后的跳转类

>6.Request类，处理http请求的类，主要是处理POST请求。使用了单例模式。操作数据库的时候，先通过这个类，筛选一下POST接收到的数据，和要操作的表的字段进行比较，去除无用的字段

>7.Tool类，公用的操作类，里面全是静态方法，都是直接调用的

>8.Tpl类。模板类，使用了单例模式

>9.Validate类，验证类，对一些常用的isArray验证进行封装，方便使用


PS:本项目没有只是实现了主要的功能，还有很多细节没有实现



